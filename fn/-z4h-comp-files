()  {
  eval "$_z4h_opt"

  local -i dot_glob list_types
  [[ $1 == on ]] && dot_glob=1
  [[ $2 == on ]] && list_types=1
  local word_prefix=$3
  local path_prefix=$4
  local -i only_dirs=$5
  local words=("${@:6}")

  compstate[list]=
  compstate[insert]=

  if (( only_dirs )); then
    if (( dot_glob )); then
      local dirs=($path_prefix${^${(Q)words:#.*}}/*(D-/Y1N:h:t))
    else
      local dirs=($path_prefix${^${(Q)words:#.*}}/*(-/Y1N:h:t))
    fi
  else
    if (( dot_glob )); then
      local dirs=($path_prefix${^${(Q)words:#.*}}/*(DY1N:h:t))
    else
      local dirs=($path_prefix${^${(Q)words:#.*}}/*(Y1N:h:t))
    fi
  fi

  local -a cmd
  if (( $#dirs )); then
    local -aU fss
    fss=(${(f)"$(command find / . -maxdepth 0 -printf '%F\n' 2>/dev/null)"}) || fss=()
    if (( $#fss )); then
      cmd+=(command find -L ./$^dirs)
      (( only_dirs )) && cmd+=('!' -type d -prune -o)
      cmd+=(-name '.*')
      if (( dot_glob )); then
        cmd+=('(' -path './*/*' -prune -print -o -prune ')')
      else
        cmd+=(-prune)
      fi
      cmd+=(-o '!' '(')
      local fs
      for fs in $fss; do
        cmd+=(-fstype $fs -o)
      done
      cmd[-1]=(')' '(' -path './*/*' -prune -print -o -prune ')')
      cmd+=(-o -path './*/*' -print)
    else
      cmd+=(command find -L . -xdev -mindepth 2)
      (( only_dirs )) && cmd+=('!' -type d -prune -o)
      cmd+=('!' '(')
      local dir
      for dir in $dirs; do
        cmd+=(-path ./${(b)dir}/'*' -o)
      done
      cmd[-1]=(')' -prune)
      cmd+=(-o -name '.*' -prune)
      (( dot_glob )) && cmd+=(-print)
      cmd+=(-o -print)
    fi
  fi

  local query char
  for char in ${(s::)words[1]}; do
    [[ -z ${words:#$query$char*} ]] || break
    query+=$char
  done

  local bind=(
    ctrl-h:backward-kill-word
    alt-j:clear-query
    ctrl-u:clear-query
    ctrl-k:kill-line
    alt-k:unix-line-discard
    tab:down
    btab:up
    ctrl-space:toggle
    ctrl-a:select-all)
  local opt=(
    --print-query
    --expect=alt-enter
    --with-nth=2
    --delimiter='\000'
    --ansi
    --exact
    --layout=reverse
    --height=$(( ! $#dirs && 100 * ($#words + 2) < 60 * LINES ? $#words + 2 : 60 * LINES / 100 ))
    --tiebreak=length,begin,index
    --multi
    --cycle
    --query=$query
    --bind=${(j:,:)bind})
  local cont
  if _fzf_tab_get -s continuous-trigger cont && [[ -n $cont ]]; then
    opt+=(--expect=$cont)
  fi

  -z4h-set-list-colors "$_fzf_tab_curcontext" "$list_types"
  local -i list_colors=$((!$?))

  autoload +X -Uz -- -z4h-present-files -z4h-cursor-show

  print >$TTY
  {
    local choice again
    choice="$(
      unsetopt pipe_fail
      exec 2>/dev/null
      [[ -n $path_prefix ]] && builtin cd -q -- $path_prefix
      {
        print -lr -- ${(Q)words}
        "${cmd[@]}" | command cut -b3-
      } | {
        -z4h-present-files $list_colors $list_types
      } | {
        -z4h-cursor-show
        $Z4H/fzf/bin/fzf $opt 2>$TTY
      }
    )" && [[ -n $choice ]] || return
    choice=("${(@f)choice}")
    case $choice[2] in
      $cont) again=1;&  # fallthrough
      '') choice=(${${choice:2}%$'\0'*});;
      alt-enter) choice=${(Q)choice[1]};;
    esac
  } always {
    print -n "$again" >$_z4h_fzf_called
    -z4h-cursor-hide
  }

  builtin compadd -QUf -p "$word_prefix" -W "$path_prefix" -- ${(@q)choice}
  if (( $#choice == 1 )); then
    compstate[insert]=2
    [[ $RBUFFER == ' '* ]] || compstate[insert]+=' '
  else
    compstate[insert]=all
  fi
} "${options[dot_glob]}" "${options[list_types]}" "$@"
