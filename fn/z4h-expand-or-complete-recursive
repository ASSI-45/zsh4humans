[[ -w $TTY && -r $TTY ]] || return

if (( ! ${+functions[-z4h-orig-path-files]} )); then
  autoload +X -Uz _path_files
  functions[-z4h-orig-path-files]=${functions[_path_files]}
fi
if (( ! ${+functions[-z4h-orig-fzf-tab-main-complete]} )); then
  functions[-z4h-orig-fzf-tab-main-complete]=${functions[_fzf_tab__main_complete]}
fi
if (( ! ${+functions[-z4h-orig-compadd]} )); then
  functions[-z4h-orig-compadd]=${functions[compadd]:-'builtin compadd "$@"'}
fi
if (( ! ${+functions[-z4h-orig-zle]} )); then
  functions[-z4h-orig-zle]=${functions[zle]:-'builtin zle "$@"'}
fi

{
  function _fzf_tab__main_complete() {
    -z4h-orig-fzf-tab-main-complete
    if (( _z4h_recursive == 1 )); then
      typeset -gi _fzf_tab_ignored=1
      -z4h-comp-files "$_z4h_word_prefix" "$_z4h_path_prefix" "$_z4h_only_dirs" "${_z4h_words[@]}"
    fi
  }
 
  function zle() {
    if [[ "${1-}" != .fzf-tab-orig-* ]]; then
      -z4h-orig-zle "$@"
      return
    fi
    (( _z4h_zle_call_num++ && _z4h_recursive == 1 )) && return
    -z4h-orig-zle "$@"
  }

  function compadd() {
    if (( _z4h_recursive != -1 )); then
      local -a opts nDOA Q f s S I W U i P p
      zparseopts -E -a opts {D,O,A}+:=nDOA n+=nDOA Q+=Q f+=f s+:=s S+:=S I+:=I W+:=W \
        U+:=U i+:=i P+:=P p+:=p {a,k,q,e,l,1,2,C}+ {F,d,J,X,x,V,r,R,E,M}+: o+::
      if (( ! $#nDOA )); then
        local -a matches
        () {
          builtin compadd -A matches "$@"
          (( ${#matches} )) || return 0
          emulate -L zsh
          (( _z4h_in_path_files && $#Q && $#f )) || return
          [[ -z $s[2] && -z $S[2] && -z $I[2] && $#W -ge 2 && $W[2] == (|*/) ]] || return
          local prefix=${U:-$IPREFIX}$i[2]$P[2]$p[2]
          if (( $#_z4h_words )); then
            [[ $W[2] == $_z4h_path_prefix && $prefix == $_z4h_word_prefix ]] || return
          else
            _z4h_word_prefix=$prefix
            _z4h_path_prefix=$W[2]
          fi
          _z4h_words+=($matches)
          if (( ! _z4h_recursive )); then
            # This used to be done only if there are non-empty dirs among $matches.
            # Now it's done unconditionally to take advantage of better file colorizer
            # and more robust fzf layount in z4h.
            _z4h_recursive=1
            typeset -gi _fzf_tab_ignored=1
          fi
        } "$@" || {
          _z4h_recursive=-1
          typeset -gi _fzf_tab_ignored=0
        }
      fi
    fi
    -z4h-orig-compadd "$@"
  }

  function _path_files() {
    local -a opts files dirs pats ignore
    zparseopts -a mopts f=files /=dirs g+:=pats F:=ignore \
      P: S: q r: R: W:  M+: J+: V+: x+: X+: 1 2 o+: n
    (( $#f || ! $#dirs )) && _z4h_only_dirs=0
    local -ir _z4h_in_path_files=1
    -z4h-orig-path-files "$@"
  }

  -z4h-cursor-hide

  local esc line col
  while true; do
    {
      -z4h-show-dots
      IFS='[;' read -s -d R esc\?$'\e[6n' line col <"$TTY" || return
      local lbuf=$LBUFFER

      {
        local _z4h_fzf_called="$Z4H"/tmp/fzf-called."${sysparams[pid]}"
        zf_rm -f -- "$_z4h_fzf_called" || return
        local _z4h_word_prefix=
        local _z4h_path_prefix=
        local -a _z4h_words=()
        local -i _z4h_recursive=0
        local -i _z4h_zle_call_num=0
        local -i _z4h_in_path_files=0
        local -i _z4h_only_dirs=1
        fzf-tab-complete
      } always {
        local -i err=$?
        local -a stat=()
        if zstat +size -A stat -- "$_z4h_fzf_called" 2>/dev/null; then
          zf_rm -f -- "$_z4h_fzf_called" || err=$?
          echoti cuu 1
          (( col > 1 )) && echoti cuf $((col-1))
        fi
        (( err )) && return err
        [[ $stat != 1 || $LBUFFER == ($lbuf|*' ') ]] && return
        zle .split-undo || return
      }
    } always {
      if (( _z4h_use[zsh-autosuggestions] && _z4h_use[zsh-syntax-highlighting] )); then
        -z4h-redraw-buffer
      fi
    }
  done
} always {
  functions[_path_files]=${functions[-z4h-orig-path-files]}
  functions[_fzf_tab__main_complete]=${functions[-z4h-orig-fzf-tab-main-complete]}
  functions[compadd]=${functions[-z4h-orig-compadd]}
  functions[zle]=${functions[-z4h-orig-zle]}
  zle -R
  -z4h-cursor-show
}
